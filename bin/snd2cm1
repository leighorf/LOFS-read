#!/usr/bin/env python
# coding: utf-8
try:
    import numpy as np
except:
    print("Error importing numpy. Is it installed?")

try:
    import sharppy.sharptab.thermo as thermo
    import sharppy.sharptab.utils as utils
    import sharppy.sharptab.profile as prof
    import sharppy.sharptab.interp as interp
    from sharppy.io import spc_decoder as spcdc
except:
    print("Error importing SHARPpy. Is it installed?")

import datetime
import argparse

def read_sharp_txt(filename, dz=100., desat=0.0, fill_to=0.0, adiabatic=0.0):
    """
    Reads in the SHARPpy file format and then does the necessary
    unit conversions and computations to have it output as a CM1
    sounding format file.
    """

    ## create the decoder object
    dc = spcdc.SPCDecoder(filename)
    ## get the profiles from the text file
    profiles = dc.getProfiles().getCurrentProfs()
    ## loop over the profiles in the file. There should
    ## at least be one. 
    for profile in profiles.values():
        P = profile.pres
        H = profile.hght
        T = profile.tmpc
        Td = profile.dwpc
        RH = profile.relh
        U = profile.u
        V = profile.v

        ## for the output file format, we don't want any missing or masked values. 
        ## This ensures that we get the combined mask from each array that matters
        ## and we only return data where stuff isn't missing. 

        ## For example, if there is missing data in the wind speed or direction column but is present
        ## in the temperature, dewpoint, height, and pressure columns, those valid numbers will be thrown out.
        ## There might be alternative ways of handling this, but this was the simplest. 
        mask = np.maximum(np.maximum(np.maximum(P.mask, H.mask), np.maximum(T.mask, Td.mask)), np.maximum(U.mask, V.mask))
        
        ## Invert the mask to get only the valid data
        P = P[~mask]
        T = T[~mask]
        Td = Td[~mask]
        RH = RH[~mask]
        H = H[~mask]
        U = U[~mask]
        V = V[~mask]

        ## Fill up data above the top if requested
        if (fill_to > 0.0):
            top_h = np.arange(H[-1], fill_to+dz, dz)
            top_p = np.zeros(top_h.shape)
            top_t = np.zeros(top_h.shape)
            top_td = np.zeros(top_h.shape)
            top_rh = np.zeros(top_h.shape)
            top_u = np.zeros(top_h.shape)
            top_v = np.zeros(top_h.shape)

            ## set the new top to be isothermal
            top_t[:] = T[-1]
            top_rh[:] = RH[-1]
            top_td[:] = Td[-1]
            top_u[:] = U[-1]
            top_v[:] = V[-1]
            ## get the last pressure value
            top_p[0] = P[-1]

            ## We need to integrate the hypsometric equation to
            ## get pressure values in dz thickness increments
            for pidx in range(len(top_p)-1):
                plower = top_p[pidx]
                pupper = plower * np.exp( (dz*9.81)/(top_t[pidx]*287.04) )
                top_p[pidx+1] = pupper 

            H = np.concatenate((H, top_h[1:]))
            P = np.concatenate((P, top_p[1:]))
            T = np.concatenate((T, top_t[1:]))
            Td = np.concatenate((Td, top_td[1:]))
            RH = np.concatenate((RH, top_rh[1:]))
            U = np.concatenate((U, top_u[1:]))
            V = np.concatenate((V, top_v[1:]))

        if (desat > 0.0): 
            RH[RH >= 98.0] -= desat
            RH[RH < 2.0] = 2.0
            satvap = thermo.vappres(T)
            vappres = (RH/100.0) * satvap
            Td = thermo.temp_at_vappres(vappres)
        else:
            RH[RH < 2.0] = 2.0
            satvap = thermo.vappres(T)
            vappres = (RH/100.0) * satvap
            Td = thermo.temp_at_vappres(vappres)

        profile = prof.create_profile(pres=P, hght=H, tmpc=T, dwpc=Td, u=U, v=V)
        
        ## interpolate the input data into a specified height interval
        ## for the output CM1 data. Defaults to 100 meters, can be specified via command line.
        new_h = np.arange(H[0], H[-1], dz)
        new_p = interp.pres(profile, new_h)
        new_t = interp.temp(profile, new_p)
        new_td = interp.dwpt(profile, new_p)
        new_u, new_v = interp.components(profile, new_p)

        new_theta = interp.theta(profile, new_p)
        if (adiabatic > 0.0):
            zmax = np.where(new_h >= adiabatic)[0][0]
            for zidx in range(len(new_h[:zmax+1])):
                T_lower = new_theta[zidx]
                T_upper = new_theta[zidx+1]
                if T_upper < T_lower:
                    new_theta[zidx+1] = T_lower
        new_mixr = interp.mixratio(profile, new_p)
        new_mixr[new_mixr < 0.01] = 0.01
        
        new_u = utils.KTS2MS(new_u)
        new_v = utils.KTS2MS(new_v)

        ## return the pre processed data for eventual writing
        return {"pres": new_p, "tmpc": new_t, "dwpc": new_td, "hght": new_h - new_h[0], "uwin": new_u, "vwin": new_v, 
            "theta": new_theta, "mixr": new_mixr}

def data_dict_to_file(data_dict, outfilename, delimiter=''):
    """
    Takes the dictionary of data and puts it into a CM1
    output file. 
    """
    outfile = open(outfilename, 'w')
    num_lines = len(list(data_dict.items())[0][1])
    
    for idx in range(num_lines):
        if idx == 0:
            line_str = ""
            line_str += "%8s" % str(format(np.around(data_dict["pres"][0], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["theta"][0], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["mixr"][0], 2), "0.2f")) + delimiter + str("\n")
            outfile.write(line_str)
        else:
            line_str = ""
            line_str += "%8s" % str(format(np.around(data_dict["hght"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["theta"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["mixr"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["uwin"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["vwin"][idx], 2), "0.2f")) + str("\n")
            outfile.write(line_str)
        
    outfile.close()
    

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--snd', action='store', dest='ifile', help='Input sounding file path', default=None, required=True)
    parser.add_argument('--cm1', action='store', dest='ofile', help='The output path for the CM1 sounding format file', default=None, required=True)
    parser.add_argument('--dz', action='store', dest='dz', help='The interpolation interval for the output data. Defaults to 100m.', default=100., required=False)
    parser.add_argument('--desat', action='store', dest='desat', help='Anywhere the profile exceeds 99% Relative Humidity, reduce the RH by this percentage', default=0.0, required=False)
    parser.add_argument('--fill-top', action='store', dest='fill_top', help='Specify a height in meters that is above the data top and fill it isothermally with constant winds', default=0.0, required=False)
    parser.add_argument('--adiabatic', action='store', dest='adiabatic', help='Ensures that the lapse rate from the surface to the given height in meters does not exceed the adiabatic lapse rate, starting at the surface. It will NOT adjust the surface T. If the surface T is in question, modify manually. ', default=0.0, required=False)
    args = parser.parse_args()

    data = read_sharp_txt(args.ifile, dz=float(args.dz), desat=float(args.desat), fill_to=float(args.fill_top), adiabatic=float(args.adiabatic))
    data_dict_to_file(data, args.ofile)

if __name__ == '__main__':
    main()

