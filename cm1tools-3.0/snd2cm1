#!/usr/bin/env python
# coding: utf-8

# In[28]:


import numpy as np
import sharppy.sharptab.thermo as thermo
import sharppy.sharptab.utils as utils
import sharppy.sharptab.profile as prof
import sharppy.sharptab.interp as interp
from sharppy.io import spc_decoder as spcdc
import datetime
import argparse

def read_sharp_txt(filename, dz=100.):
    """
    Reads in the SHARPpy file format and then does the necessary
    unit conversions and computations to have it output as a CM1
    sounding format file.
    """

    ## create the decoder object
    dc = spcdc.SPCDecoder(filename)
    ## get the profiles from the text file
    profiles = dc.getProfiles().getCurrentProfs()
    ## loop over the profiles in the file. There should
    ## at least be one. 
    for profile in profiles.values():
        P = profile.pres
        H = profile.hght
        T = profile.tmpc
        Td = profile.dwpc
        U = profile.u
        V = profile.v

        ## for the output file format, we don't want any missing or masked values. 
        ## This ensures that we get the combined mask from each array that matters
        ## and we only return data where stuff isn't missing. 

        ## For example, if there is missing data in the wind speed or direction column but is present
        ## in the temperature, dewpoint, height, and pressure columns, those valid numbers will be thrown out.
        ## There might be alternative ways of handling this, but this was the simplest. 
        mask = np.maximum(np.maximum(np.maximum(P.mask, H.mask), np.maximum(T.mask, Td.mask)), np.maximum(U.mask, V.mask))
        
        ## Invert the mask to get only the valid data
        P = P[~mask]
        T = T[~mask]
        Td = Td[~mask]
        H = H[~mask]
        U = U[~mask]
        V = V[~mask]
        
        ## interpolate the input data into a specified height interval
        ## for the output CM1 data. Defaults to 100 meters, can be specified via command line.
        new_h = np.arange(H[0], H[-1], dz)
        new_p = interp.pres(profile, new_h)
        new_t = interp.temp(profile, new_p)
        new_td = interp.dwpt(profile, new_p)
        new_u, new_v = interp.components(profile, new_p)
        new_theta = interp.theta(profile, new_p)
        new_mixr = interp.mixratio(profile, new_p)
        
        new_u = utils.KTS2MS(new_u)
        new_v = utils.KTS2MS(new_v)
        ## return the pre processed data for eventual writing
        return {"pres": new_p, "tmpc": new_t, "dwpc": new_td, "hght": new_h - new_h[0], "uwin": new_u, "vwin": new_v, 
            "theta": new_theta, "mixr": new_mixr}

def data_dict_to_file(data_dict, outfilename, delimiter=''):
    """
    Takes the dictionary of data and puts it into a CM1
    output file. 
    """
    outfile = open(outfilename, 'w')
    num_lines = len(list(data_dict.items())[0][1])
    
    for idx in range(num_lines):
        if idx == 0:
            line_str = ""
            line_str += "%8s" % str(format(np.around(data_dict["pres"][0], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["theta"][0], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["mixr"][0], 2), "0.2f")) + delimiter + str("\n")
            outfile.write(line_str)
        else:
            line_str = ""
            line_str += "%8s" % str(format(np.around(data_dict["hght"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["theta"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["mixr"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["uwin"][idx], 2), "0.2f")) + delimiter + str("\t")
            line_str += "%8s" % str(format(np.around(data_dict["vwin"][idx], 2), "0.2f")) + str("\n")
            outfile.write(line_str)
        
    outfile.close()
    

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--snd', action='store', dest='ifile', help='Input sounding file path', default=None, required=True)
    parser.add_argument('--cm1', action='store', dest='ofile', help='The output path for the CM1 sounding format file', default=None, required=True)
    parser.add_argument('--dz', action='store', dest='dz', help='The interpolation interval for the output data. Defaults to 100m.', default=100., required=False)
    args = parser.parse_args()

    data = read_sharp_txt(args.ifile, dz=float(args.dz))
    data_dict_to_file(data, args.ofile)

if __name__ == '__main__':
    main()

